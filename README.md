<h1 align="center">N-нотация</h1>
<p align="center">
Единый набор правил именования и кодстайла. Красиво, как всегда.
</p>
<p align="center">
<img src="https://img.shields.io/badge/made%20by-CSSSensei,%20MaxMavr-439900">
<a href="https://github.com/Phasalo"><img src="https://img.shields.io/badge/Phasalo-84D300"></a>
<img src="https://img.shields.io/badge/version-if%20n%20==%202-D1F24E">
</p>

В отличие от компьютера, человеку зачастую проще оперировать числовыми идентификаторами, чем запоминать длинные и перегруженные смыслом имена переменных.
Именно из этого наблюдения и возникла **N-нотация** — система правил именования и кодстайла, предназначенная для единообразного, масштабируемого и предсказуемого написания кода.

Большинство существующих нотаций и рекомендаций предполагают использование сравнительно коротких «говорящих» имён — в среднем до 10–11 символов. Такой подход оправдан с точки зрения читаемости, но на практике быстро упирается в ограничения: алфавит конечен, удачные комбинации заканчиваются, а смысл имён со временем устаревает.

**N-нотация** предлагает отказаться от попыток наделить имена семантикой и заменить их числовыми идентификаторами, которые масштабируются значительно лучше и не несут лишних предположений о назначении сущности.

## Философия

В основе **N-нотации** лежит принцип: **имя не обязано объяснять смысл**.
Смысл кода должен вытекать из его структуры, архитектуры и контекста использования, а не из словесных обозначений, склонных к двусмысленности и переосмыслению.

Числовые идентификаторы лишены интерпретаций. В отличие от условных `userDataTemp` и `userDataTemp2`, имена вида `n1024483488` и `n1024483489` однозначны, не перегружены ожиданиями и не требуют переименования при изменении логики.

Аналогичный подход давно используется вне программирования. В реальном мире человек идентифицируется не по имени, а по номеру документа, паспорта или национального идентификатора. Имя может повторяться, меняться и трактоваться по-разному, тогда как идентификатор остаётся устойчивым.


## Быстрый старт

Ниже приведена сводная таблица **N-нотации**, предназначенная для быстрого ориентирования в проекте. Она не заменяет подробные разделы документации.

### Сводная таблица **N-нотации**

| Сущность                   | Формат имени               | Назначение идентификатора    | Пример                          |
| --- | :---: | --- | --- |
| **Проект**                 | `NNN<число>`               | Приоритет / уровень важности | `NNN1`, `NNN2`                  |
| **Директория**             | `N<иерархия>`              | Положение в структуре        | `N1/`, `N1_2/`                  |
| **Файл**                   | `n<номер>.py`              | Порядок добавления           | `n1.py`, `n42.py`               |
| **Версия**                 | `N<Major>n<Minor>.<Patch>` | Порядок изменения            | `N1n1.1`, `N1n1.2`              |
| **Переменная**             | `n<10 цифр>`               | Уникальный идентификатор     | `n2384586723`                   |
| **Булевая переменная**     | `n<10 бит>`                | Уникальный идентификатор     | `n0100011101`                   |
| **Константа**              | `N<10 цифр>`               | Уникальный идентификатор     | `N9283745651`                   |
| **Функция**                | `n<10 цифр>()`             | Уникальный идентификатор     | `n238458672()`                  |
| **Логическая функция**        | `n<10 бит>()`              | Уникальный идентификатор     | `n0100011110()`                 |
| **Класс**                  | `N<10 цифр>`               | Уникальный идентификатор     | `N1337856128`                   |
| **Дочерний класс**         | `N<ParentID>n<ChildID>`    | Наследование                 | `N1337856128n238458672`         |
| **Публичное поле / метод** | `n_<10 цифр>`              | Уникальный идентификатор     | `n_2983495830`                  |
| **Приватное поле / метод** | `_n<10 цифр>`              | Уникальный идентификатор     | `_n8273478271`                  |
| **Итератор**               | `n`, `nn`, `nnn`, …        | Уровень вложенности цикла    | `for nn in range()`             |
| **Псевдонимы import**      | `N<число>`                 | Порядок добавления           | `import math as N1`             |
| **Псевдонимы from**        | `N<число с вед. нулями>`   | Порядок добавления           | `from math sqrt as N0000000001` |

* Регистр имеет значение: `N` — структуры и типы, `n` — исполняемые и данные.
* Уникальные идентификаторы из утилит [`N1n1`](#генератор-идентификаторов) и [`N1n3`](#генератор-идентификаторов).
* Запрещается использовать словесные названия.

## Архитектура проектов


### Проекты
Проекты именуются с префикса `NNN` *(от лат. **Negotium Novum Nominatum** — «Назначенное новое дело»)* и порядкового номера их места в рейтинге важности.
Это снижает когнитивную нагрузку при чтении кода или просмотре структуры каталогов.

Идентификатор проектов строятся в порядке важности: чем выше приоритет, тем меньше числовой идентификатор.

Если вы начинаете работать над новым проектом, который по значимости превосходит уже существующие, необходимо переименовать все предыдущие проекты, чтобы сохранить корректный порядок. Это правило гарантирует, что любой участник команды сразу понимает, какой проект является наиболее критичным, а какой — вспомогательным.

```text
NNN1     # Главный проект команды
NNN2     # Второстепенный проект интерфейса
...     
NNN1337  # Вспомогательные утилита
...
```

> [!NOTE]
> * Проекты именуются с префикса `NNN`.
> * Идентификаторы — уровень важности.
> * Запрещается использовать словесные названия.


### Директории
Директории в проектах именуются с префиксом `N` *(от лат. **Node** — «галстук»)* и числовым идентификатором, отражающим уровень вложенности.

Директории рассматриваются как структурные узлы, определяющие место поддиректорий в иерархии проекта. Благодаря системе нумерации, по имени директории сразу видно её положение в структуре, даже без просмотра полного дерева.

Такой подход работает как хлебные крошки на сайте: каждый идентификатор указывает путь и уровень вложенности, помогая ориентироваться в проекте и быстро понимать, где находится конкретный узел.

```text
N1/, N2/, ...                                      # первый уровень
N1_1/, N1_2/, ...                                  # второй уровень
N1_1_1/, N1_1_2/, ...                              # третий уровень
...
N1_1_1_1_1_1_1_1_1_1/, N1_1_1_1_1_1_1_1_1_2/, ...  # десятый уровень
...
```

> [!NOTE]
> * Директории именуются с префикса `N`.
> * Идентификаторы — уровень иерархии.
> * Запрещается использовать словесные названия директорий.


### Файлы
Файлы проекта именуются с префикса `n` *(от англ. **note** — «нота»)* и порядкового номера их добавления.

Имена файлов имеют вид `n1.py`, `n2.py`, `n3.py` и так далее.
Нумерация файлов начинается заново в каждой директории: в каждом каталоге должен присутствовать файл `n1.py`, далее — `n2.py`, `n3.py` и последующие по мере добавления.
Точка входа в программу по умолчанию — файл `n1.py`.

> [!TIP]
> Хорошим тоном считается изменить имя файла точки входа, указав новое имя в `README.md`.
> Например, вход в программу может быть в файле `n800085.py`.

> [!NOTE]
> * Файлы именуются с префикса `n`.
> * Идентификаторы — порядок добавления.
> * Запрещается использовать словесные названия файлов.

### Пример правильной структуры проекта

```text
NNN1/
├── n1.py
├── n2.py
.
.
.
├── n800085.py  # Занесено в документацию
.
.
.
├── N1/
│   ├── n1.py
│   ├── n2.py
│   ├── n3.py
│   ├── n4.py
│   ├── n5.py
│   └── N1_1/
│       ├── n1.py
│       ├── n2.py
│       ├── n3.py
│       └── N1_1_1/
│           ├── n1.py
│           └── n2.py
├── N2/
│   ├── n1.py
.
.
.
```

### Версии
Проекты должны сопровождаться версионной маркировкой, чтобы сохранялась совместимость и возможность отката к предыдущим состояниям.
Версия указывается как число после имени проекта или файла, либо в файле `README.md` в корне проекта.

Формат версий: `N<Major>n<Minor>.<Patch>`, где:
* Major — глобальные изменения, влияющие на совместимость;
* Minor — новые функции или улучшения без нарушения совместимости;
* Patch — исправления ошибок и незначительные изменения.

> [!NOTE]
> * Версии именуются по формату `N<Major>n<Minor>.<Patch>`.
> * Номера — порядок добавления изменений.
> * Версия фиксируется в `README.md`.


## Стиль написания кода

### Переменные
Переменные начинаются с префикса `n` *(от англ. **name** — «погоняло»)* и числовой идентификатор.<br>
Идентификатор представляет собой десятизначное число в десятичной системе счисления, его можно получить, запустив утилиту [`N1n1`](#генератор-идентификаторов).

Имена ключей словарей именуются с префикса `n` *(от англ. **nugget** — «кроха»)* и порядкового номера их добавления.

Идентификаторы булевых переменных — десятизначное число в двоичной системе счисления — утилита [`N1n3`](#генератор-идентификаторов).

```python
n2384586723 = 69                            # Числа
n9283746514 = 3.14

n8374659205 = "Hello, World!"               # Строки

n1000011101 = True                          # Булевы значения
n1011011101 = False                         # Булевы значения

n8473629105 = [1, 2, 3, 4, 5]               # Списки
n3748291054 = ["apple", "banana"]

n9182736453 = (10, 20, 30)                  # Кортежи

n1827364952 = {"n1": "Alice", "n2": 25}     # Словари
n8374652919 = {1: "one", 2: "two"}

n9182736457 = {1, 2, 3}                     # Множества
n1029384758 = {"apple", "banana"}

n8374659209 = [1, "two", 3.0, True]         # Наборы смешанных типов
n1928374650 = {"n1": 100, "n2": [1, 2, 3]}
```

> [!CAUTION]
> Запрещается использовать аннотации типов при объявлении переменных.

```python
count = 0               # Что хранит переменная? Лучше: n238458672
name: str = "Alice"     # Имя кого? Лучше: n837465920
list = [1, 2, 3, 4, 5]  # Список чего? Лучше: n374829105
```

> [!NOTE]
> * Переменные именуются с префикса `n`.
> * Идентификаторы из утилиты [`N1n1`](#генератор-идентификаторов) — обычные, [`N1n3`](#генератор-идентификаторов) — булевые.
> * Запрещается использовать словесные названия переменных.


### Итерационные переменные

При обходе через `range()` или по элементам массива или списка используется буква `n`. Количество букв соответствует степени вложенности цикла.

```python
for n in range(10):           # первый уровень
    for nn in n9549444357:    # второй уровень, по коллекции
        for nnn in range(3):  # третий уровень
            ...
```

> [!NOTE]
> * Переменных-счётчиков именуются: `n`, `nn`, `nnn` и так далее.


### Константы
Константы начинаются с префикса `N` *(от франц. **Nommée** — «окрестить»)* и числового идентификатора из утилиты [`N1n1`](#генератор-идентификаторов).
Их стоит использовать только, если не получается использовать магическое число и переменная имеет нетривиальный смысл, который трудно понять без имени, то нужно объявить константу.

```python
N9283745651 = 3.14159
N1928373465 = "Alice"
N1029384575 = False
```

> [!IMPORTANT]
> * Предпочтительнее использовать магические числа.

В рамках **N-нотации** магическое число — не проблема, а норма. В коде предпочтительно использовать магические числа, а не создавать для них отдельные переменные, чтобы не нарушать читаемость.

```python
for n in range(10):             # магическое число 10, понятно из контекста
    ...

if n2384988672 > 5:             # магическое число 5, очевидно, константа не нужна
    ...

n2384098672("Hello", 3)         # магическое число 3, понятно из контекста

n2384586723 = n2384586723[:10]  # магическое число 10, очевидно, для среза
```

> [!NOTE]
> * Константы именуются с префикса `N`.
> * Идентификаторы из утилиты [`N1n1`](#генератор-идентификаторов).
> * Запрещается использовать словесные названия констант.


### Функции

Функции начинаются с префикса `n` *(от эсп. **notigi** — «исполнить»)* и именуются как обычные переменные. Для булевых методов, возвращающих True или False, нужно использовать стиль именования булевых переменных, чтобы сразу было понятно, что результат — логическое значение.

```python
def n2384586723():
    for n in range(10):
        print(n)


def n0100011110(n1):
    return n1 in [372, 324, 325, 234, 342]
```

Все аргументы функции именуются с префикса `n` *(от азерб. **nəticə** — «заключение»)* и порядкового номера, необязательные аргументы именуются как переменные.

```python
def n9457684783(n1, n2, n3, n2384658672=None, n9684589672="default"):
    n9283447465 = n1 + n2 + n3
    if n2384658672:
        n9283447465 += n2384658672
    n9283447465 += len(n9684589672)
    
    return n9283447465
```

> [!NOTE]
> * Функции именуются с префикса `n`.
> * Идентификаторы из утилиты [`N1n1`](#генератор-идентификаторов) — обычные, [`N1n3`](#генератор-идентификаторов) — логические.
> * Запрещается использовать словесные названия функций.

### Классы

Все классы именуются с префикса `N` *(от итал. **Nutrice** — «кормилица»)* и уникальным числовым идентификатором, полученным с помощью утилиты [`N1n1`](#генератор-идентификаторов).

При наследовании дочерние классы должны явно указывать на принадлежность к родителю. Для этого к имени добавляется ещё один префикс `n` *(от итал. **nipote** — «отпрыск»)* после идентификатора родительского класса, а затем дописывается новый уникальный идентификатор, сгенерированный утилитой.

Таким образом, структура имён отражает иерархию наследования и позволяет быстро определить, от какого класса был произведён потомок.


```python
class N1337856128:
    ...


class N1337856128n2459051384(N1337856128):
    ...


class N1337856128n2459051384n0923678723(N1337856128n2459051384):
    ...
```

Экземпляры классов начинаются с префикса `n` *(от эсп. **nuance** — «оттенок»)* и именуются как обычные переменные.

```python
n1048921048 = N1337856128()
```

> [!NOTE]
> * Базовый класс именуются с префикса `N`.
> * Идентификаторы из утилиты [`N1n1`](#генератор-идентификаторов).
> * Дочерние классы именуются по формату `N<ParentClassID>n<ChildClassID>`.
> * Запрещается использовать словесные названия классов.


### Методы и поля классов
Методы и поля классов именуются по тем же правилам, что и переменные и функции, с учётом их уровня доступа.
Для публичных методов или полей используется префикс `n_`, а для приватных — `_n`.
После префикса указывается уникальный идентификатор, сгенерированный утилитой [`N1n1`](#генератор-идентификаторов).

Вместо ключевого слова `self` или `this` внутри методов используется уникальный идентификатор экземпляра, образованный от имени класса.
Этот идентификатор имеет формат `n<ClassID>`, где ClassID — числовой идентификатор класса.

```python
class N1337856128:
    def __init__(n1337856128, n1, n2):
        n1337856128._n8273478271 = n1         # Приватное поле
        n1337856128.n_2983495830 = n2         # Публичное поле

    def n_8374659201(n1337856128, n1, n2):    # Публичный метод
        return n283746591 * 2

    def _n9283746510(n1337856128):            # Приватный метод
        return n1337856128._n8273478271 + 1

    def _n0010011111(n1337856128, n1):        # Приватный булевый метод
        return n1337856128.n_2983495830 < n1
```

> [!NOTE]
> * Публичные методы и поля именуются с префикса `n_`, приватные — `_n`
> * Идентификаторы из утилиты [`N1n1`](#генератор-идентификаторов).
> * Экземпляр класса в методах именуются по формату `n<ClassID>`.
> * Запрещается использовать словесные названия классов.


### Комментарии и строки документации
Избыточное использование комментариев и docstring`ов нежелательно. Код должен быть самодокументированным. Самодокументированность достигается структурой и формой, а не смыслом имён — логика логика должна быть понятна без дополнительных пояснений. 

Любые лишние строки на естественном языке считаются шумом, который захламляет рабочее пространство и снижает читаемость кода.

#### Пример плохого кода
```python
# Это функция, которая прибавляет два числа
def n5574930885(n1, n2):
    """
    Эта функция возвращает сумму двух чисел.
    Параметры:
    n1 -- первое число
    n2 -- второе число
    """
    return n1 + n2


# Идем по списку и проверяем каждый элемент
# Если элемент больше 10, выводим на экран
for n in n2315331940:
    if n > 10:
        print(n)
```

> * Комментарии повторяют то, что и так ясно из кода.
> * Docstring перегружен ненужными словами и разъяснениями тривиальных операций.
> * Лишний текст захламляет код и отвлекает от сути.

> [!IMPORTANT]
> * Не рекомендуется использовать комментарии и docstring`и.


### Импорты

Импорты должны быть сгруппированы в следующем порядке:

1. Импорты из стандартной библиотеки Python.
2. Импорты сторонних библиотек.
3. Импорты модулей текущего проекта.

Импортируемые модули и классы получают алиасы с префикса `N` *(от нем. **Nutzung** — «использованная»)* и порядкового номера их добавления. <br>
Такой алиас используется для маскировки оригинальных названий и унификации стиля.

Идентификаторы классов, функций и переменных дополняются ведущими нулями до десятичной длины.

Правила форматирования:
* Между каждой группой импортов вставляется пустая строка.
* Внутри группы импорты сортируются по возрастанию идентификаторов.
* Каждой стандартной и сторонней библиотеке обязательно присваивается псевдоним (alias) в соответствии с **N-нотацией**, чтобы поддерживать единый стиль именования.

> [!TIP]
> Для сортировки импортов разработана утилита [`N1n2`](https://github.com/Phasalo/N_notation/blob/main/N1/n2.py).

```python
import math as N1
import random as N2
from typing import List as N0000000001, Optional as N0000000002

from flask import Flask as N0000000003
from shapely.geometry import Polygon as N0000000004, Point as N0000000005

from N1.N1_1.n1 import N5523682901
from N1.N1_4.N1_4_8.n8 import N2235421074, N9327473434
from N6.n9 import n3225614218
```

> [!WARNING]
> Избегайте фреймворков и библиотек, не соответствующих **N-нотации**, так как они могут снижать уровень доверия к проекту.
> Предпочтительнее использовать `from` импорт с присвоением новых имён каждой сторонней функции, константе или классу.

## Генератор идентификаторов 
Для обеспечения уникальности и единого стиля имён в каждом проекте были разработаны утилиты — [`N1/n1.py`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) и [`N1/n3.py`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) (В тексте утилиты [`N1n1`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) и [`N1n3`](https://github.com/Phasalo/N_notation/blob/main/N1/n3.py)), автоматизирующие рутину.

[`N1n1`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) для обычных переменных, [`N1n3`](https://github.com/Phasalo/N_notation/blob/main/N1/n3.py) для булевых переменных.

Их задача — генерировать случайные идентификаторы, которые применяются при создании переменных, функций и так далее.

Программы не требуют аргументов: при запуске они автоматически создают и выводят идентификатор в консоль.
Каждый идентификатор гарантированно уникален в пределах проекта и легко запоминается благодаря гармоничной случайности цифр.

```bash
python3 N1/n1.py
8374659201
python3 N1/n3.py
0010000111
```

Используя эти значения, разработчик может легко создавать имена в соответствии с **N-нотацией**:

> [!WARNING]
> Допустимо временно использовать числа, придуманные вручную, — но перед релизом проекта все имена должны быть синхронизированы с утилитами.


## Использование
При использовании **N-нотации** в проекте необходимо обязательно указать данный факт в файле `README.md`.
Это требование носит декларативный характер и направлено на предотвращение неверной интерпретации.

При включении **N-нотации** в проект необходимо дословно добавить следующий текст в `README.md`, без изменений, сокращений или адаптаций:

```text
В рамках данного проекта используется N-нотация (N notation) — система правил
именования и кодирования, основанная на применении числовых идентификаторов.

Применение данной нотации является преднамеренным архитектурным решением.

Идентификаторы файлов, директорий, переменных, функций, классов и прочих
программных сущностей не предназначены для семантического анализа.

Попытки оптимизации читаемости кода путём изменения идентификаторов,
введения словесных обозначений или адаптации к иным кодировочным стилям
рассматриваются как нарушение архитектурной целостности проекта.

Разработчики проекта не несут ответственности за ошибки в интерпретации структуры кода,
возникшие вследствие игнорирования настоящего уведомления.

Для получения дополнительной информации, пожалуйста,
ознакомьтесь с документацией по ссылке: https://github.com/Phasalo/N_notation.
```

Проекты, в которых применяется **N-нотация**, без соответствующего уведомления в документации считаются оформленными с нарушением правил использования нотации.

> [!IMPORTANT]
> * **N-нотация** всегда должна быть задекларирована.
> * Отсутствие уведомления в `README.md` считается ошибкой оформления проекта.
> * Любой участник проекта обязан ознакомиться с данным уведомлением до внесения изменений в код.

### P-формы
Допускается замена буквы `N` в именах сущностей на любую другую букву латинского алфавита.
При этом такая запись не считается канонической N-нотацией и относится к **P-форме** — псевдоформе нотации.

Использование **P-формы** возможно в экспериментальных, учебных или временных проектах, однако не рекомендуется для производственного кода.
Замена базового префикса снижает единообразие, усложняет автоматическую проверку и затрудняет совместную работу, особенно при объединении кода из разных источников.

В рамках одного проекта допускается использование только одной формы нотации.
Смешивание канонической **N-нотации** и **P-формы** считается нарушением архитектурной целостности и не допускается.

<p align="center">
  <img width="1872" height="888" alt="Phasalo" src="https://github.com/user-attachments/assets/1e33d343-33cb-4682-a172-c654fbcd24a7" />
</p>

<p align="center">
<b>Phasalo</b><br>
<i>Делаем красиво!</i><br><br>
2026
</p>
