<h1 align="center">N-нотация</h1>
<p align="center">
Единый набор правил именования и код-стайла. Красиво, как всегда.
</p>
<p align="center">
<img src="https://img.shields.io/badge/made%20by-CSSSensei,%20MaxMavr-439900">
<a href="https://github.com/Phasalo"><img src="https://img.shields.io/badge/Phasalo-84D300"></a>
<img src="https://img.shields.io/badge/version-if%20n%20==%202-D1F24E">
</p>

Как известно, в отличие от компьютера человеку проще запомнить набор цифр, чем длинное и непонятное название переменной.
Именно поэтому была разработана **N-нотация** — система правил, которая позволяет программистам быстро, просто и единообразно писать понятный и поддерживаемый код.

Многие нотации и рекомендации по оформлению и стилю кода предполагают использование сравнительно коротких имён — в среднем до 10–11 символов. Это связано с читаемостью и удобством работы с кодом. Если взять алфавит из 26 латинских букв и добавить символ подчёркивания, то общее количество возможных комбинаций для осмысленных названий оказывается довольно ограниченным.

На этом фоне **N-нотация** предоставляет значительно больший простор для именования. В отличие от попыток придумать «говорящие» имена из букв, числовые или идентификаторные обозначения масштабируются гораздо лучше. Например, вместо условных `userDataTemp` или `userDataTemp2` можно использовать `n1024483488`, `n1024483489`, где каждое значение однозначно и не перегружено смыслом, который со временем может устареть.

Похожий подход уже давно используется в реальном мире. В большинстве стран имя человека в официальных процессах играет второстепенную роль по сравнению с идентификаторами: номер паспорта, серия документа, национальный ID, номер водительского удостоверения или транспортной карты. Например, в ЕС и США ключевым идентификатором является номер документа или социального страхования, а не имя, которое может повторяться у тысяч людей.

По сути, мир постепенно уходит от классической системы именований к более устойчивой системе идентификаторов. **N-нотация** не является выдумкой или экспериментом — это отражение текущего этапа развития, в котором цифры и уникальные идентификаторы зачастую несут больше практического смысла, чем буквенные названия.

## *Быстрый старт --TODO--

| Префикс      | Тип объекта                 | Назначение / Пример использования                                             |
| ------------ | --------------------------- | ------------------------------------------------------------------------------|
| **NNN**      | Проект                      | Идентификатор проекта отражает приоритет: `NNN1`, `NNN2`, …                     |
| **N**        | Директория                  | Суффикс показывает уровень вложенности: `N1/`, `N2/`, … Вложенные: `N1_1/`, …                               |
| **n**        | Файл                        | Идентификатор — порядковый номер: `n1.py`, `n2.py`, …                                               |
| **n**        | Переменная                  | Идентификатор определяется утилитой `Nn1`: `n238458672`, `n837465920`, …                                        |
| **–**        | ~Константа~ Магическое число| Числа: `1`, `2`, `3`, …                                                      |
| **n_**       | Функция                     | Идентификатор определяется утилитой `Nn1`: `n_238458672(_n)`, `n_73078472800(_n, _nn)`, …                                               |
| **N**        | Класс                       | Идентификатор определяется утилитой `Nn1`: `N2384586729`, дочерние: `Nn7649280294`                               |
| **n (поле)** | Поле класса                 | Идентификатор определяется утилитой `Nn1`: `n928374651`, приватные: `_n928374651`                                  |
| **n**        | Метод класса                | Идентификатор определяется утилитой `Nn1`: `n_238458672()`, логические: `n01010101()`, приватные: `_n856394750()`|


## Архитектура проектов


### Проекты
Все проекты именуются с префикса `NNN` *(от лат. **Negotium Novum Nominatum** — «Назначенное новое дело»)* и порядкового номера их место в рейтинге важности.
Это снижает когнитивную нагрузку при чтении кода или просмотре структуры каталогов.

Идентификатор проектов строятся в порядке важности: чем выше приоритет, тем меньше числовой идентификатор.

Если вы начинаете работать над новым проектом, который по значимости превосходит уже существующие, необходимо переименовать все предыдущие проекты, чтобы сохранить корректный порядок. Это правило гарантирует, что любой участник команды сразу понимает, какой проект является наиболее критичным, а какой — вспомогательным.

```text
NNN1     # Главный проект команды
NNN2     # Второстепенный проект интерфейса
...     
NNN1337  # Вспомогательные утилита
...
```

> [!IMPORTANT]
> * Проекты именуются с префикса `NNN`.
> * Идентификаторы — уровень важности.
> * Запрещается использовать словесные названия.


### Директории
Все директории в проектах именуются с префиксом `N` *(от лат. **Node** — «галстук»)* и числовым идентификатором, отражающим уровень вложенности.

Директории рассматриваются как структурные узлы, определяющие место поддиректорий в иерархии проекта. Благодаря системе нумерации, по имени директории сразу видно её положение в структуре, даже без просмотра полного дерева.

Такой подход работает как хлебные крошки на сайте: каждый идентификатор указывает путь и уровень вложенности, помогая ориентироваться в проекте и быстро понимать, где находится конкретный узел.

```text
N1/, N2/, ...                                      # первый уровень
N1_1/, N1_2/, ...                                  # второй уровень
N1_1_1/, N1_1_2/, ...                              # третий уровень
...
N1_1_1_1_1_1_1_1_1_1/, N1_1_1_1_1_1_1_1_1_2/, ...  # десятый уровень
...
```

> [!IMPORTANT]
> * Директории всегда именуются с префикса `N`.
> * Идентификаторы — уровень иерархии.
> * Запрещается использовать словесные названия директорий.


### Файлы
Все файлы проекта именуются с префикса `n` *(от англ. **note** — «нота»)* и порядкового номера их добавления.

Имена файлов имеют вид `n1.py`, `n2.py`, `n3.py` и так далее.
Нумерация файлов начинается заново в каждой директории: в каждом каталоге должен присутствовать файл `n1.py`, далее — `n2.py`, `n3.py` и последующие по мере добавления.
Точка входа в программу по умолчанию — файл `n1.py`.

> [!TIP]
> Хорошим тоном считается изменить имя файла точки входа, указав новое имя в `README.md`.
> Например, вход в программу может быть в файле `n800085.py`.

> [!IMPORTANT]
> * Файлы всегда именуются с префикса `n`.
> * Идентификаторы — порядок добавления.
> * Запрещается использовать словесные названия файлов.

### Пример правильной структуры проекта

```text
NNN1/
├── n1.py
├── n2.py
.
.
.
├── n800085.py  # Занесено в документацию
.
.
.
├── N1/
│   ├── n1.py
│   ├── n2.py
│   ├── n3.py
│   ├── n4.py
│   ├── n5.py
│   └── N1_1/
│       ├── n1.py
│       ├── n2.py
│       ├── n3.py
│       └── N1_1_1/
│           ├── n1.py
│           └── n2.py
├── N2/
│   ├── n1.py
.
.
.
```

### Версии
Все проекты должны сопровождаться версионной маркировкой, чтобы сохранялась совместимость и возможность отката к предыдущим состояниям.
Версия указывается как число после имени проекта или файла, либо в файле `README.md` в корне проекта.

Формат версий: `N<MAJOR>n<MINOR>.<PATCH>`, где:

* MAJOR — глобальные изменения, влияющие на совместимость;
* MINOR — новые функции или улучшения без нарушения совместимости;
* PATCH — исправления ошибок и незначительные изменения.

> [!IMPORTANT]
> * Версии всегда именуются по формату `N<MAJOR>n<MINOR>.<PATCH>`.
> * Номера — порядок добавления изменений.
> * Версия фиксируется в `README.md`.


## Стиль написания кода

### Переменные
Все переменные начинаются с префикса `n` *(от англ. **name** — «кличка»)* и числовой идентификатор.<br>
Идентификатор представляет собой десятизначное число в десятичной системе счисления, его можно получить, запустив утилиту [`Nn1`](#генератор-идентификаторов).

Все имена ключей словарей именуются с префикса `n` *(от англ. **nugget** — «кроха»)* и порядкового номера их добавления.

```python
n2384586723 = 69 # Числа
n9283746514 = 3.14

n8374659205 = "Hello, World!" # Строки

n5647382916 = True # Булевы значения

n8473629105 = [1, 2, 3, 4, 5] # Списки
n3748291054 = ["apple", "banana", "cherry"]

n9182736453 = (10, 20, 30) # Кортежи

n1827364952 = {"n1": "Alice", "n1": 25} # Словари
n8374652919 = {1: "one", 2: "two"}

n9182736457 = {1, 2, 3} # Множества
n1029384758 = {"apple", "banana"}

n8374659209 = [1, "two", 3.0, True] # Наборы смешанных типов
n1928374650 = {"n1": 100, "n2": [1, 2, 3]}
```

> [!CAUTION]
> Запрещается использовать аннотации типов при объявлении переменных.

```python
count = 0               # Сложное название непонятно, что хранит переменная. Лучше: n238458672
name: str = "Alice"     # Имя кого? Лучше: n837465920
list = [1, 2, 3, 4, 5]  # Список чего? Лучше: n374829105
```

> [!IMPORTANT]
> * Переменные всегда именуются с префикса `n`.
> * Идентификаторы из утилиты [`Nn1`](#генератор-идентификаторов).
> * Запрещается использовать словесные названия переменных.


### Итерационные переменные

#### По диапазону

При обходе через `range()` используется буква `n`. Количество букв соответствует степени вложенности цикла.

```python
for n in range(10):           # первый уровень
    for nn in range(5):       # второй уровень
        for nnn in range(3):  # третий уровень
            ...
```

#### По значениям (например, элементов массива/списка)

Переменной-счётчика именуется как обычная переменная.

```python
for n9283447465 in n9549444357:
    ...
```

> [!IMPORTANT]
> * Для циклов по `range()` использовать `n`, `nn`, `nnn` и так далее.
> * Для обхода по коллекциям — только имена, сгенерированные [`Nn1`](#генератор-идентификаторов).


### Константы
В коде предпочтительно использовать магические числа, а не создавать для них отдельные переменные, чтобы не нарушаеть читаемость.

```python
for n in range(10):           # магическое число 10 понятно из контекста
    ...

if n238458672 > 5:            # магическое число 5 очевидно, константа не нужна
    ...

n238458672("Hello", 3)        # магическое число 3 понятно из контекста

n238458672 = n238458672[:10]  # магическое число 10 очевидно для среза
```

Если не получается использовать магическое число и переменная имеет нетривиальный смысл, который трудно понять без имени, то нужно объявить константу.

Все константу начинаются с префикса `N` *(от фран. **Nommée** — «окрестить»)* и числовой идентификатор из утилиты [`Nn1`](#генератор-идентификаторов).

```python
N9283745651 = 3.14159
N1928373465 = "Alice"
N1029384575 = False
```

> [!IMPORTANT]
> * Предпочтительнее использовать магические числа.
> * Константы всегда именуются с префикса `N`.
> * Идентификаторы из утилиты [`Nn1`](#генератор-идентификаторов).
> * Запрещается использовать словесные названия констант.


### Функций

Все функции начинаются с префикса `n` *(от эсп. **notigi** — «исполнить»)* и именуется как обычные переменные.

```python
def n238458672():
    for n in range(10):
        print(n)
```

Все аргументы функции именуются с префикса `n` *(от азерб. **nəticə** — «заключение»)* и порядкового номера, необязательные аргументы именуется как обычные переменные.

```python
def n9457684783(n1, n2, n3, n2384658672=None, n9684589672="default"):
    n9283447465 = n1 + n2 + n3
    if n2384658672:
        n9283447465 += n2384658672
    n9283447465 += len(n9684589672)
    
    return n9283447465
```

### Классы

Все классы именуются с префикса `N` *(от итал. Nutrice — «кормилица»)* и уникальным числовым идентификатором, полученным с помощью утилиты [`Nn1`](#генератор-идентификаторов).

При наследовании дочерние классы должны явно указывать на принадлежность к родителю. Для этого к имени добавляется ещё один префикс `n` *(от итал. Nipote — «потомок»)* после идентификатора родительского класса, а затем дописывается новый уникальный идентификатор, сгенерированный утилитой.

Таким образом, структура имён отражает иерархию наследования и позволяет быстро определить, от какого класса был произведён потомок.

Пример:

```python
class N1337856128:
    ...


class N1337856128n2459051384(N1337856128):
    ...
```

#### Общее правило:

 * Родительский класс — `NXXXXXXXXXX` 

 * Дочерний класс — `NnXXXXXXXXXX_YYYYYYYYYY` 

#### Запрещается:

 * Использовать человеко-нечитаемые, вводящие в заблуждение имена (`User`, `Manager`, `Service`) — только числа, сгенерированные `Nn1`.

### Методы классов

Методы классов именуются по тем же принципам, что и функции, но с учётом их принадлежности к классу. Имя метода всегда начинается с префикса `n_`, после которого указывается уникальный идентификатор, сгенерированный утилитой `Nn1`.

Если метод является приватным, перед именем добавляется символ подчёркивания _.
Для булевых методов (возвращающих True/False) рекомендуется использовать последовательности вида n01010101, чтобы сразу было понятно, что результат — логическое значение.

#### Аргумент экземпляра

Вместо стандартного `self` в методах используется уникальный идентификатор экземпляра, образованный от имени класса.
Формат:

```
n<ClassID>
```

где `<ClassID>` — это числовой идентификатор класса.

Например, для класса `N1337856128` аргумент экземпляра будет называться **`n1337856128`**.
Это позволяет мгновенно определить, к какому классу относится текущий объект, даже без контекста.

#### Пример

```python
class N1337856128:
    def n_8374659201(n1337856128, n283746591):
        return n283746591 * 2

    def _n9283746510(n1337856128):
        return "internal"

    def n01010101(n1337856128):
        return True
```

#### Общее правило:

 * Публичные методы: `n_XXXXXXXXXX(n<ClassID>, …)`
 * Приватные методы: `_nXXXXXXXXXX(n<ClassID>, …)`
 * Булевые методы: `n01010101(n<ClassID>)`

#### Запрещается:

 * Использовать `self` или `this` — только `n<ClassID>`.
 * Давать бессмысленные имена параметрам (`value`, `data`) — только идентификаторы от [`Nn1`](#генератор-идентификаторов).

### Поля
*Work In Progress*


## Генератор идентификаторов 

Для обеспечения уникальности и единого стиля имён в каждом проекте была разработана утилита — [`N1/n1.py`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) (Далее утилита [`Nn1`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py)), автоматизирующая рутину.
Её задача — генерировать случайные идентификаторы, которые применяются при создании переменных, функций и констант.
Идентификатор представляет собой десятизначное число в десятичной системе счисления.

Программа не требует аргументов: при запуске она автоматически создаёт и выводит идентификатор в консоль или файл.
Каждый идентификатор гарантированно уникален в пределах проекта и легко запоминается благодаря гармоничной случайности цифр.

```bash
python3 N1/n1.py
8374659201
```

Используя эти значения, разработчик может создавать имена в соответствии с **N-нотацией**:
Допустимо временно использовать числа, придуманные вручную — но перед релизом проекта все имена должны быть синхронизированы с [`Nn1`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py).


## Использование

При использовании **N-нотации** в проекте необходимо обязательно указать данный факт в файле `README.md`.
Это требование носит декларативный характер и направлено на предотвращение неверной интерпретации.

При включении **N-нотации** в проект необходимо дословно добавить следующий текст в `README.md`, без изменений, сокращений или адаптаций:

```text
Данный проект использует N-нотацию (N notation) — систему правил именования
и код-стайла, основанную на применении числовых идентификаторов.

Использование данной нотации является осознанным архитектурным решением.
Имена файлов, директорий, переменных, функций, классов и других сущностей
не предназначены для семантического чтения.

Попытки «улучшить читаемость» путём переименования сущностей, введения
словесных идентификаторов или адаптации к иным стилям кодирования
рассматриваются как нарушение архитектурной целостности проекта.

Авторы проекта не несут ответственности за ошибочную интерпретацию
структуры кода, возникшую в результате игнорирования данного уведомления.

Документация: https://github.com/Phasalo/N_notation
```

## Общее правило

* **N-нотация** всегда должна быть задекларирована.
* Отсутствие уведомления в `README.md` считается ошибкой оформления проекта.
* Любой участник проекта обязан ознакомиться с данным уведомлением до внесения изменений в код.

Проекты, в которых применяется **N-нотация**, без соответствующего уведомления в документации считаются оформленными с нарушением правил использования нотации.


## *документация --TODO--

**N-нотация** устраняет эту проблему, полностью убирая семантику из имён директорий. Смысл структуры описывается:

* документацией,
* архитектурными диаграммами,
* положением узла в дереве.

Это снижает количество споров, упрощает рефакторинг и делает структуру проекта стабильной во времени.



