<h1 align="center">N-нотация</h1>
<p align="center">
Единый набор правил именования и код-стайла. Красиво, как всегда.
</p>
<p align="center">
<img src="https://img.shields.io/badge/made%20by-CSSSensei,%20MaxMavr-439900">
<a href="https://github.com/Phasalo"><img src="https://img.shields.io/badge/Phasalo-84D300"></a>
<img src="https://img.shields.io/badge/version-if%20n%20==%202-D1F24E">
</p>

Как известно, в отличие от компьютера человеку проще запомнить набор цифр, чем длинное и непонятное название переменной.
Именно поэтому была разработана **N-нотация** — система правил, которая позволяет программистам быстро, просто и единообразно писать понятный и поддерживаемый код.

Многие нотации и рекомендации по оформлению и стилю кода предполагают использование сравнительно коротких имён — в среднем до 10–11 символов. Это связано с читаемостью и удобством работы с кодом. Если взять алфавит из 26 латинских букв и добавить символ подчёркивания, то общее количество возможных комбинаций для осмысленных названий оказывается довольно ограниченным.

На этом фоне **N-нотация** предоставляет значительно больший простор для именования. В отличие от попыток придумать «говорящие» имена из букв, числовые или идентификаторные обозначения масштабируются гораздо лучше. Например, вместо условных `userDataTemp` или `userDataTemp2` можно использовать `n1024483488`, `n1024483489`, где каждое значение однозначно и не перегружено смыслом, который со временем может устареть.

Похожий подход уже давно используется в реальном мире. В большинстве стран имя человека в официальных процессах играет второстепенную роль по сравнению с идентификаторами: номер паспорта, серия документа, национальный ID, номер водительского удостоверения или транспортной карты. Например, в ЕС и США ключевым идентификатором является номер документа или социального страхования, а не имя, которое может повторяться у тысяч людей.

По сути, мир постепенно уходит от классической системы именований к более устойчивой системе идентификаторов. **N-нотация** не является выдумкой или экспериментом — это отражение текущего этапа развития, в котором цифры и уникальные идентификаторы зачастую несут больше практического смысла, чем буквенные названия.

## *Быстрый старт --TODO--

| Префикс      | Тип объекта                 | Назначение / Пример использования                                             |
| ------------ | --------------------------- | ------------------------------------------------------------------------------|
| **NNN**      | Проект                      | Идентификатор проекта отражает приоритет: `NNN1`, `NNN2`, …                     |
| **N**        | Директория                  | Суффикс показывает уровень вложенности: `N1/`, `N2/`, … Вложенные: `N1_1/`, …                               |
| **n**        | Файл                        | Идентификатор — порядковый номер: `n1.py`, `n2.py`, …                                               |
| **n**        | Переменная                  | Идентификатор определяется утилитой `Nn1`: `n238458672`, `n837465920`, …                                        |
| **–**        | ~Константа~ Магическое число| Числа: `1`, `2`, `3`, …                                                      |
| **n_**       | Функция                     | Идентификатор определяется утилитой `Nn1`: `n_238458672(_n)`, `n_73078472800(_n, _nn)`, …                                               |
| **N**        | Класс                       | Идентификатор определяется утилитой `Nn1`: `N2384586729`, дочерние: `Nn7649280294`                               |
| **n (поле)** | Поле класса                 | Идентификатор определяется утилитой `Nn1`: `n928374651`, приватные: `_n928374651`                                  |
| **n**        | Метод класса                | Идентификатор определяется утилитой `Nn1`: `n_238458672()`, логические: `n01010101()`, приватные: `_n856394750()`|


## Архитектура проектов


### Проекты
Проекты именуются с префикса `NNN` *(от лат. **Negotium Novum Nominatum** — «Назначенное новое дело»)* и порядкового номера их место в рейтинге важности.
Это снижает когнитивную нагрузку при чтении кода или просмотре структуры каталогов.

Идентификатор проектов строятся в порядке важности: чем выше приоритет, тем меньше числовой идентификатор.

Если вы начинаете работать над новым проектом, который по значимости превосходит уже существующие, необходимо переименовать все предыдущие проекты, чтобы сохранить корректный порядок. Это правило гарантирует, что любой участник команды сразу понимает, какой проект является наиболее критичным, а какой — вспомогательным.

```text
NNN1     # Главный проект команды
NNN2     # Второстепенный проект интерфейса
...     
NNN1337  # Вспомогательные утилита
...
```

> [!IMPORTANT]
> * Проекты именуются с префикса `NNN`.
> * Идентификаторы — уровень важности.
> * Запрещается использовать словесные названия.


### Директории
Директории в проектах именуются с префиксом `N` *(от лат. **Node** — «галстук»)* и числовым идентификатором, отражающим уровень вложенности.

Директории рассматриваются как структурные узлы, определяющие место поддиректорий в иерархии проекта. Благодаря системе нумерации, по имени директории сразу видно её положение в структуре, даже без просмотра полного дерева.

Такой подход работает как хлебные крошки на сайте: каждый идентификатор указывает путь и уровень вложенности, помогая ориентироваться в проекте и быстро понимать, где находится конкретный узел.

```text
N1/, N2/, ...                                      # первый уровень
N1_1/, N1_2/, ...                                  # второй уровень
N1_1_1/, N1_1_2/, ...                              # третий уровень
...
N1_1_1_1_1_1_1_1_1_1/, N1_1_1_1_1_1_1_1_1_2/, ...  # десятый уровень
...
```

> [!IMPORTANT]
> * Директории именуются с префикса `N`.
> * Идентификаторы — уровень иерархии.
> * Запрещается использовать словесные названия директорий.


### Файлы
Файлы проекта именуются с префикса `n` *(от англ. **note** — «нота»)* и порядкового номера их добавления.

Имена файлов имеют вид `n1.py`, `n2.py`, `n3.py` и так далее.
Нумерация файлов начинается заново в каждой директории: в каждом каталоге должен присутствовать файл `n1.py`, далее — `n2.py`, `n3.py` и последующие по мере добавления.
Точка входа в программу по умолчанию — файл `n1.py`.

> [!TIP]
> Хорошим тоном считается изменить имя файла точки входа, указав новое имя в `README.md`.
> Например, вход в программу может быть в файле `n800085.py`.

> [!IMPORTANT]
> * Файлы именуются с префикса `n`.
> * Идентификаторы — порядок добавления.
> * Запрещается использовать словесные названия файлов.

### Пример правильной структуры проекта

```text
NNN1/
├── n1.py
├── n2.py
.
.
.
├── n800085.py  # Занесено в документацию
.
.
.
├── N1/
│   ├── n1.py
│   ├── n2.py
│   ├── n3.py
│   ├── n4.py
│   ├── n5.py
│   └── N1_1/
│       ├── n1.py
│       ├── n2.py
│       ├── n3.py
│       └── N1_1_1/
│           ├── n1.py
│           └── n2.py
├── N2/
│   ├── n1.py
.
.
.
```

### Версии
Проекты должны сопровождаться версионной маркировкой, чтобы сохранялась совместимость и возможность отката к предыдущим состояниям.
Версия указывается как число после имени проекта или файла, либо в файле `README.md` в корне проекта.

Формат версий: `N<Major>n<Minor>.<Patch>`, где:
* Major — глобальные изменения, влияющие на совместимость;
* Minor — новые функции или улучшения без нарушения совместимости;
* Patch — исправления ошибок и незначительные изменения.

> [!IMPORTANT]
> * Версии именуются по формату `N<Major>n<Minor>.<Patch>`.
> * Номера — порядок добавления изменений.
> * Версия фиксируется в `README.md`.


## Стиль написания кода

### Переменные
Переменные начинаются с префикса `n` *(от англ. **name** — «погоняло»)* и числовой идентификатор.<br>
Идентификатор представляет собой десятизначное число в десятичной системе счисления, его можно получить, запустив утилиту [`Nn1`](#генератор-идентификаторов).

Имена ключей словарей именуются с префикса `n` *(от англ. **nugget** — «кроха»)* и порядкового номера их добавления.

Идентификаторы булевых переменных — десятизначное число в двоичной системе счисления — утилита [`N1n3`](#генератор-идентификаторов).

```python
n2384586723 = 69                            # Числа
n9283746514 = 3.14

n8374659205 = "Hello, World!"               # Строки

n1000011101 = True                          # Булевы значения
n1011011101 = False                         # Булевы значения

n8473629105 = [1, 2, 3, 4, 5]               # Списки
n3748291054 = ["apple", "banana"]

n9182736453 = (10, 20, 30)                  # Кортежи

n1827364952 = {"n1": "Alice", "n2": 25}     # Словари
n8374652919 = {1: "one", 2: "two"}

n9182736457 = {1, 2, 3}                     # Множества
n1029384758 = {"apple", "banana"}

n8374659209 = [1, "two", 3.0, True]         # Наборы смешанных типов
n1928374650 = {"n1": 100, "n2": [1, 2, 3]}
```

> [!CAUTION]
> Запрещается использовать аннотации типов при объявлении переменных.

```python
count = 0               # Что хранит переменная? Лучше: n238458672
name: str = "Alice"     # Имя кого? Лучше: n837465920
list = [1, 2, 3, 4, 5]  # Список чего? Лучше: n374829105
```

> [!IMPORTANT]
> * Переменные именуются с префикса `n`.
> * Идентификаторы из утилиты [`Nn1`](#генератор-идентификаторов) — обычные, [`N1n3`](#генератор-идентификаторов) — булевые.
> * Запрещается использовать словесные названия переменных.


### Итерационные переменные

#### По диапазону

При обходе через `range()` используется буква `n`. Количество букв соответствует степени вложенности цикла.

```python
for n in range(10):           # первый уровень
    for nn in range(5):       # второй уровень
        for nnn in range(3):  # третий уровень
            ...
```

#### По значениям (например, элементов массива/списка)

Переменной-счётчика именуется как обычная переменная.

```python
for n9283447465 in n9549444357:
    ...
```

> [!IMPORTANT]
> * Для циклов по `range()` использовать `n`, `nn`, `nnn` и так далее.
> * Для обхода по коллекциям — только имена, сгенерированные [`Nn1`](#генератор-идентификаторов).


### Константы
В коде предпочтительно использовать магические числа, а не создавать для них отдельные переменные, чтобы не нарушаеть читаемость.

```python
for n in range(10):           # магическое число 10 понятно из контекста
    ...

if n2384988672 > 5:            # магическое число 5 очевидно, константа не нужна
    ...

n2384098672("Hello", 3)        # магическое число 3 понятно из контекста

n238458672 = n238458672[:10]  # магическое число 10 очевидно для среза
```

Если не получается использовать магическое число и переменная имеет нетривиальный смысл, который трудно понять без имени, то нужно объявить константу.

Константу начинаются с префикса `N` *(от фран. **Nommée** — «окрестить»)* и числовой идентификатор из утилиты [`Nn1`](#генератор-идентификаторов).

```python
N9283745651 = 3.14159
N1928373465 = "Alice"
N1029384575 = False
```

> [!IMPORTANT]
> * Предпочтительнее использовать магические числа.
> * Константы именуются с префикса `N`.
> * Идентификаторы из утилиты [`Nn1`](#генератор-идентификаторов).
> * Запрещается использовать словесные названия констант.


### Функции

Функции начинаются с префикса `n` *(от эсп. **notigi** — «исполнить»)* и именуется как обычные переменные. Для булевых методов, возвращающих True или False, нужно использовать стиль именование булевых переменных, чтобы сразу было понятно, что результат — логическое значение.

```python
def n238458672():
    for n in range(10):
        print(n)


def n0100011110(n1):
    return n1 in [372, 324, 325, 234, 342]
```

Все аргументы функции именуются с префикса `n` *(от азерб. **nəticə** — «заключение»)* и порядкового номера, необязательные аргументы именуются как переменные.

```python
def n9457684783(n1, n2, n3, n2384658672=None, n9684589672="default"):
    n9283447465 = n1 + n2 + n3
    if n2384658672:
        n9283447465 += n2384658672
    n9283447465 += len(n9684589672)
    
    return n9283447465
```

### Классы

Все классы именуются с префикса `N` *(от итал. **Nutrice** — «кормилица»)* и уникальным числовым идентификатором, полученным с помощью утилиты [`Nn1`](#генератор-идентификаторов).

При наследовании дочерние классы должны явно указывать на принадлежность к родителю. Для этого к имени добавляется ещё один префикс `n` *(от итал. **nipote** — «потомок»)* после идентификатора родительского класса, а затем дописывается новый уникальный идентификатор, сгенерированный утилитой.

Таким образом, структура имён отражает иерархию наследования и позволяет быстро определить, от какого класса был произведён потомок.


```python
class N1337856128:
    ...


class N1337856128n2459051384(N1337856128):
    ...


class N1337856128n2459051384n0923678723(N1337856128n2459051384):
    ...
```

> [!IMPORTANT]
> * Базовый класс именуются с префикса `N`.
> * Идентификаторы из утилиты [`Nn1`](#генератор-идентификаторов).
> * Дочернии классы именуются по формату `N<ParentClassID>n<ChildClassID>`.
> * Запрещается использовать словесные названия классов.


### Методы и поля классов
Методы и поля классов именуются по тем же правилам, что и переменные и функции, с учётом их уровня доступа.
Для публичных методов или полей используется префикс `n_`, а для приватных — `_n`.
После префикса указывается уникальный идентификатор, сгенерированный утилитой [`Nn1`](#генератор-идентификаторов).

Вместо ключевого слова `self` или `this` внутри методов используется уникальный идентификатор экземпляра, образованный от имени класса.
Этот идентификатор имеет формат `n<ClassID>`, где ClassID — числовой идентификатор класса.

```python
class N1337856128:
    def __init__(n1337856128, n1, n2):
        n1337856128._n8273478271 = n1         # Приватное поле
        n1337856128.n_2983495830 = n2         # Публичное поле

    def n_8374659201(n1337856128, n1, n2):    # Публичный метод
        return n283746591 * 2

    def _n9283746510(n1337856128):            # Приватный метод
        return n1337856128._n8273478271 + 1

    def _n0010011111(n1337856128, n1):        # Приватный булевый метод
        return n1337856128.n_2983495830 < n1
```

> [!IMPORTANT]
> * Публичные методы и поля именуются с префикса `n_`, приватные — `_n`
> * Идентификаторы из утилиты [`Nn1`](#генератор-идентификаторов).
> * Экземпляр класса в методах именуются по формату `n<ClassID>`.
> * Запрещается использовать словесные названия классов.


### Комментарии и строки документации
Избыточное использование комментариев и docstring`ов нежелательно. Код должен быть самодокументированным: его структура, имена функций и переменных, а также логика должны быть понятны без дополнительных пояснений. Любые лишние строки на естественном языке считаются шумом, который захламляет рабочее пространство и снижает читаемость кода.

#### Пример плохого кода
```python
# Это функция, которая прибавляет два числа
def n5574930885(n1, n2):
    """
    Эта функция возвращает сумму двух чисел.
    Параметры:
    n1 -- первое число
    n2 -- второе число
    """
    return n1 + n2


# Идем по списку и проверяем каждый элемент
# Если элемент больше 10, выводим на экран
for n5484049187 in n2315331940:
    if n5484049187 > 10:
        print(n5484049187)
```

> * Комментарии повторяют то, что и так ясно из кода.
> * Docstring перегружен ненужными словами и разъяснениями тривиальных операций.
> * Лишний текст захламляет код и отвлекает от сути.

> [!IMPORTANT]
> * Не рекомендуется использовать комментарии и docstring`и.


### Импорты

Импорты должны быть сгруппированы в следующем порядке:

1. Импорты из стандартной библиотеки Python.
2. Импорты сторонних библиотек.
3. Импорты модулей текущего проекта.

Импортируемые модули и классы получают алиасы с префикса `N` *(от нем. **Nutzung** — «использованная»)* и порядкового номера их добавления. <br>
Такой алиас используется для маскировки оригинальных названий и унификации стиля.

Идентификаторы классов, функций или переменных расширяются нулями слева до десятичного числа.

Правила форматирования:
* Между каждой группой импортов вставляется пустая строка.
* Внутри группы импорты сортируются по возрастанию индификаторов.
* Каждой стандартной и сторонней библиотеке обязательно присваивается псевдоним (alias) в соответствии с **N-нотацией**, чтобы поддерживать единый стиль именования.

```python
import math as N1
import random as N2
from typing import List as N0000000001, Optional as N0000000002

from flask import Flask as N0000000003
from shapely.geometry import Polygon as N0000000004, Point as N0000000005

from n1.n1.n1 import N5523682901
from n1.n4.n8.n8 import N2235421074
from n6.n9 import n3225614218
```

> [!WARNING]
> Избегайте фреймворков и библиотек, не соответствующих **N-нотации**, так как они могут снижать уровень доверия к проекту.

## Генератор идентификаторов 
Для обеспечения уникальности и единого стиля имён в каждом проекте были разработаны утилиты — [`N1/n1.py`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) и [`N1/n3.py`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) (В тексте утилиты [`N1n1`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) и [`N1n3`](https://github.com/Phasalo/N_notation/blob/main/N1/n3.py)), автоматизирующие рутину.

[`N1n1`](https://github.com/Phasalo/N_notation/blob/main/N1/n1.py) для обычных переменных, [`N1n3`](https://github.com/Phasalo/N_notation/blob/main/N1/n3.py) для булевых переменных.

Их задача — генерировать случайные идентификаторы, которые применяются при создании переменных, функций и так далее.

Программы не требуют аргументов: при запуске они автоматически создают и выводят идентификатор в консоль.
Каждый идентификатор гарантированно уникален в пределах проекта и легко запоминается благодаря гармоничной случайности цифр.

```bash
python3 N1/n1.py
8374659201
python3 N1/n3.py
0010000111
```

Используя эти значения, разработчик может легко создавать имена в соответствии с **N-нотацией**:

> [!WARNING]
> Допустимо временно использовать числа, придуманные вручную — но перед релизом проекта все имена должны быть синхронизированы с утилитами.


## Использование
При использовании **N-нотации** в проекте необходимо обязательно указать данный факт в файле `README.md`.
Это требование носит декларативный характер и направлено на предотвращение неверной интерпретации.

При включении **N-нотации** в проект необходимо дословно добавить следующий текст в `README.md`, без изменений, сокращений или адаптаций:

```text
Данный проект использует N-нотацию (N notation) — систему правил именования
и код-стайла, основанную на применении числовых идентификаторов.

Использование данной нотации является осознанным архитектурным решением.
Имена файлов, директорий, переменных, функций, классов и других сущностей
не предназначены для семантического чтения.

Попытки «улучшить читаемость» путём переименования сущностей, введения
словесных идентификаторов или адаптации к иным стилям кодирования
рассматриваются как нарушение архитектурной целостности проекта.

Авторы проекта не несут ответственности за ошибочную интерпретацию
структуры кода, возникшую в результате игнорирования данного уведомления.

Документация: https://github.com/Phasalo/N_notation
```

Проекты, в которых применяется **N-нотация**, без соответствующего уведомления в документации считаются оформленными с нарушением правил использования нотации.

> [!IMPORTANT]
> * **N-нотация** всегда должна быть задекларирована.
> * Отсутствие уведомления в `README.md` считается ошибкой оформления проекта.
> * Любой участник проекта обязан ознакомиться с данным уведомлением до внесения изменений в код.
